##########Debugging
Test incrementally: Every well-written program is composed of small, modular components that can be tested individually. Try out everything you write as soon as possible to identify problems early and gain confidence in your components.

Isolate errors: An error in the output of a statement can typically be attributed to a particular modular component. When trying to diagnose a problem, trace the error to the smallest fragment of code you can before trying to correct it.

Check your assumptions: Interpreters do carry out your instructions to the letter â€” no more and no less. Their output is unexpected when the behavior of some code does not match what the programmer believes (or assumes) that behavior to be. Know your assumptions, then focus your debugging effort on verifying that your assumptions actually hold.

Consult others: You are not alone! If you don't understand an error message, ask a friend, instructor, or search engine. If you have isolated an error, but can't figure out how to correct it, ask someone else to take a look. A lot of valuable programming knowledge is shared in the process of group problem solving.

##################
bind the func names
n % i == 0
return if else
float int type / //

#################NOTES###############
'''
prompt >>> 2021

Expression (evaluzted in the context of environment
Call exp: 1. operator then operand subexpressions 2. apply func (val of operator subexp) to argu
mul(add(1, 2), 2)
'''

'''
assignment, name, user-defined func (initial)

Assignment is a simple mean of abstraction: bind names to values
max is initialize as built-in func 1st, if max = 7, it was assigned as 7
primitive 
call
'''

'''
Environment Diagrams: 
  a sequances of frames; 
  name eval to val bound to the name in the earliest frame
  

Defining Function
bind names to expression



'''

